// This file was automatically generated by genny.
// Any changes will be lost if this file is regenerated.
// see https://github.com/CanDIG/genny

package transformations

import (
	"github.com/go-openapi/strfmt"

	apimodels "github.com/CanDIG/go-model-service/variant-service/api/models"

	datamodels "github.com/CanDIG/go-model-service/variant-service/data/models"

	"github.com/CanDIG/go-model-service/variant-service/errors"

	"github.com/gobuffalo/pop"
)

// IndividualDataToAPIModel transforms a data.models representation of the Individual from the pop ORM-like
// to an api.models representation of the Individual from the Go-Swagger-defined API.
// This allows for the movement of Individual data from the database to the server for GET requests.Individual
// An *apimodels.Error pointer is returned alongside the transformed Individual for ease of error
// response, as it can be used as the response payload immediately.
func IndividualDataToAPIModel(dataIndividual datamodels.Individual) (*apimodels.Individual, *apimodels.Error) {
	funcName := "transformations.IndividualDataToAPIModel"

	apiIndividual, errPayload := individualToAPI(dataIndividual)
	if errPayload != nil {
		return nil, errPayload
	}

	err := apiIndividual.Validate(strfmt.NewFormats())
	if err != nil {
		errors.Log(err, 500, funcName,
			"API schema validation for API-model Individual failed upon transformation")
		errPayload := errors.DefaultInternalServerError()
		return nil, errPayload
	}

	return apiIndividual, nil
}

//TODO is it really ok to have the validation occur here, with only a Save in configure_Individual_service following the Individual
// IndividualAPIToDataModel transforms an api.models representation of the Individual from the Go-Swagger-
// defined API to a data.models representation of the Individual from the pop ORM-like.
// This allows for the movement of Individual data from the server to the database for POST/PUT/DELETE
// requests.
// The transformed Individual is validated within this function prior to its return.
// An *apimodels.Error pointer is returned alongside the transformed Individual for ease of error
// response, as it can be used as the response payload immediately.
func IndividualAPIToDataModel(apiIndividual apimodels.Individual, tx *pop.Connection) (*datamodels.Individual, *apimodels.Error) {
	funcName := "transformations.IndividualAPIToDataModel"

	dataIndividual, errPayload := individualToData(apiIndividual)
	if errPayload != nil {
		return nil, errPayload
	}

	validationErrors, err := dataIndividual.Validate(tx)
	if err != nil {
		errors.Log(err, 500, funcName,
			"Data schema validation for data-model Individual failed upon transformation with the following validation errors:\n"+
				validationErrors.Error()) // Print validation error messages into logged message string
		errPayload := errors.DefaultInternalServerError()
		return nil, errPayload
	}

	return dataIndividual, nil
}

// VariantDataToAPIModel transforms a data.models representation of the Variant from the pop ORM-like
// to an api.models representation of the Variant from the Go-Swagger-defined API.
// This allows for the movement of Variant data from the database to the server for GET requests.Variant
// An *apimodels.Error pointer is returned alongside the transformed Variant for ease of error
// response, as it can be used as the response payload immediately.
func VariantDataToAPIModel(dataVariant datamodels.Variant) (*apimodels.Variant, *apimodels.Error) {
	funcName := "transformations.VariantDataToAPIModel"

	apiVariant, errPayload := variantToAPI(dataVariant)
	if errPayload != nil {
		return nil, errPayload
	}

	err := apiVariant.Validate(strfmt.NewFormats())
	if err != nil {
		errors.Log(err, 500, funcName,
			"API schema validation for API-model Variant failed upon transformation")
		errPayload := errors.DefaultInternalServerError()
		return nil, errPayload
	}

	return apiVariant, nil
}

//TODO is it really ok to have the validation occur here, with only a Save in configure_Variant_service following the Variant
// VariantAPIToDataModel transforms an api.models representation of the Variant from the Go-Swagger-
// defined API to a data.models representation of the Variant from the pop ORM-like.
// This allows for the movement of Variant data from the server to the database for POST/PUT/DELETE
// requests.
// The transformed Variant is validated within this function prior to its return.
// An *apimodels.Error pointer is returned alongside the transformed Variant for ease of error
// response, as it can be used as the response payload immediately.
func VariantAPIToDataModel(apiVariant apimodels.Variant, tx *pop.Connection) (*datamodels.Variant, *apimodels.Error) {
	funcName := "transformations.VariantAPIToDataModel"

	dataVariant, errPayload := variantToData(apiVariant)
	if errPayload != nil {
		return nil, errPayload
	}

	validationErrors, err := dataVariant.Validate(tx)
	if err != nil {
		errors.Log(err, 500, funcName,
			"Data schema validation for data-model Variant failed upon transformation with the following validation errors:\n"+
				validationErrors.Error()) // Print validation error messages into logged message string
		errPayload := errors.DefaultInternalServerError()
		return nil, errPayload
	}

	return dataVariant, nil
}

// CallDataToAPIModel transforms a data.models representation of the Call from the pop ORM-like
// to an api.models representation of the Call from the Go-Swagger-defined API.
// This allows for the movement of Call data from the database to the server for GET requests.Call
// An *apimodels.Error pointer is returned alongside the transformed Call for ease of error
// response, as it can be used as the response payload immediately.
func CallDataToAPIModel(dataCall datamodels.Call) (*apimodels.Call, *apimodels.Error) {
	funcName := "transformations.CallDataToAPIModel"

	apiCall, errPayload := callToAPI(dataCall)
	if errPayload != nil {
		return nil, errPayload
	}

	err := apiCall.Validate(strfmt.NewFormats())
	if err != nil {
		errors.Log(err, 500, funcName,
			"API schema validation for API-model Call failed upon transformation")
		errPayload := errors.DefaultInternalServerError()
		return nil, errPayload
	}

	return apiCall, nil
}

//TODO is it really ok to have the validation occur here, with only a Save in configure_Call_service following the Call
// CallAPIToDataModel transforms an api.models representation of the Call from the Go-Swagger-
// defined API to a data.models representation of the Call from the pop ORM-like.
// This allows for the movement of Call data from the server to the database for POST/PUT/DELETE
// requests.
// The transformed Call is validated within this function prior to its return.
// An *apimodels.Error pointer is returned alongside the transformed Call for ease of error
// response, as it can be used as the response payload immediately.
func CallAPIToDataModel(apiCall apimodels.Call, tx *pop.Connection) (*datamodels.Call, *apimodels.Error) {
	funcName := "transformations.CallAPIToDataModel"

	dataCall, errPayload := callToData(apiCall)
	if errPayload != nil {
		return nil, errPayload
	}

	validationErrors, err := dataCall.Validate(tx)
	if err != nil {
		errors.Log(err, 500, funcName,
			"Data schema validation for data-model Call failed upon transformation with the following validation errors:\n"+
				validationErrors.Error()) // Print validation error messages into logged message string
		errPayload := errors.DefaultInternalServerError()
		return nil, errPayload
	}

	return dataCall, nil
}
