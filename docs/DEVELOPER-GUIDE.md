# Developer Guide

This guide contains tips and tricks for using the code-generation tools presented in this model service.

Note that most auto-generated code, including binary files such as `main`, have been excluded from this repository. The exclusion of these files is considered to be best practice for repository maintenance. However, one-time auto-generated files that are *not* re-generated (and are therefore safe to edit) should be pushed to this repository. `model-vs/api/restapi/configure_variant_service.go` and the `model-vs/data/models` package are examples of such safe-to-edit auto-generated code.

<!-- @import "[TOC]" {cmd="toc" depthFrom=1 depthTo=6 orderedList=false} -->
<!-- code_chunk_output -->

- [Developer Guide](#developer-guide)
  - [Go-Swagger](#go-swagger)
    - [Generating The Server](#generating-the-server)
      - [Boilerplate Code and Directory Structure](#boilerplate-code-and-directory-structure)
    - [Adding New Endpoints](#adding-new-endpoints)
  - [GoBuffalo Pop](#gobuffalo-pop)
    - [Pop Migrations](#pop-migrations)
      - [Migrating Pop Models](#migrating-pop-models)
      - [Representing Associations with Pop](#representing-associations-with-pop)
    - [Validating Pop Models](#validating-pop-models)
      - [Handling Nulls With Pop](#handling-nulls-with-pop)
    - [$POP_PATH](#pop_path)
  - [Genny](#genny)
  - [Postman](#postman)
  - [Docker](#docker)
    - [Environment Variables for Docker Containers](#environment-variables-for-docker-containers)

<!-- /code_chunk_output -->

## Go-Swagger

Go-Swagger reads the API definition for a service and automatically generates the boilerplate Go code needed to build the server.

See [goswagger.io](https://goswagger.io/) for installation instructions, tutorials, use-cases, etc. If you find yourself having trouble with the installation, check the [prerequisites](https://goswagger.io/generate/requirements.html). The [Todo List Tutorial](https://goswagger.io/tutorial/todo-list.html) (Simple Server) is a good place to start if you've never used go-swagger before.

Go-Swagger uses Swagger 2.0, which is based on the OpenAPI specification. "Swagger" and "OpenAPI" are often used interchangeably. See [this post](https://swagger.io/blog/api-strategy/difference-between-swagger-and-openapi/) for an explanation of the relationship between the two.

### Generating The Server

The API definitions are written by the developer in a `swagger.yml` file. To validate that the `swagger.yml` file follows the specification, run:
```
swagger validate <path-to-swagger-spec>
```

To auto-generate a server based on the entities and endpoints described in the `swagger.yml` file, run:
```
swagger generate server -A <server-name> <path-to-swagger-spec>.
```
For example, for this service, from the `go-model-service/model-vs/api` directory, you would run the following to re-generate the server:
```
swagger generate server -A model-vs swagger.yml
```

The backend can now be implemented by modifying the endpoint handlers in `restapi/configure_<server-name>.go`. The connection to the database or ORM is made in these handlers. Other configuration such as middleware setup is also written in this file, in the respective methods.

#### Boilerplate Code and Directory Structure

All files in the api directory are auto-generated (and auto-replaced upon calling
`$ swagger generate server <path-to-swagger-spec>`) except for the following:
- `swagger.yml`: The swagger definition.
- `configure_variant_service.go`: Auto-generated but safe to edit.
- `main`: Generated by calling `$ go build cmd/model-vs-server/main.go`

The auto-generated boilerplate code includes:
- **models**
API-facing models for data objects are generated into the `models` package.
Models are generated from the `definitions` specified in the `swagger.yml` file.
- **endpoints**
The endpoints for the API are specified in `paths` in the `swagger.yml` file, and from their definition the `operations` package is populated with endpoint parameters, validation, responses, URL building, etc.
However the backend handlers for these endpoints, ie. what is done with the received request, must be written manually in confifure_variant_service.go, in the configureAPI method. By default, the handlers return `501: Not Implemented` responses.
- **server**
The go server files and main.go are auto-generated.
- **configuration**
The `configure_variant_service.go` file is auto-generated but safe to edit. This is where the manually written backend goes, where requests are handled following their automatic transformation into go structs, and where responses/payloads are assigned.
Middleware can be plugged in here.
The connection to the data backend/memory store (ie. the ORM and/or database) should be made here.

### Adding New Endpoints

To prevent overwrite of the backend implementation, the `restapi/configure_<server-name>.go` file is not re-generated if it already exists. Therefore, if new paths are added in the `swagger.yml` file, new handlers for those paths will not be automatically generated into the existing `restapi/configure_<server-name>.go` file. Moving the existing file to a different directory will allow swagger to generate the configuration file with the up-to-date set of handlers upon the next call of `swagger generate server`. The two copies of the file can then be reconciled to include both the new handlers and the previously-implemented ones. 

## GoBuffalo Pop

Pop is an ORM-like that is used to interface between a go backend and a database.

See the [pop README](https://github.com/gobuffalo/pop#pop--) for installation and use instructions. Most documentation is now maintained at [gobuffalo.io](https://gobuffalo.io/en/docs/db/getting-started/) in the `Database` section. There is also an [Unofficial pop Book](https://andrew-sledge.gitbooks.io/the-unofficial-pop-book/content/) with tutorials, [Quick Start](https://andrew-sledge.gitbooks.io/the-unofficial-pop-book/content/installation.html) being a good place to begin.

Note that if you are using `sqlite3` as your database, there are slight modifications that must be made to some commands in the form of a `-tags sqlite` option. These are detailed in the [Installing CLI Support](https://github.com/gobuffalo/pop#installing-cli-support) section of the Pop documentation.

### Pop Migrations

Soda is a CLI tool for generating pop migration files and models, as well as for running up- and down-migrations. Migrations are described in `.fizz` or `.sql` files. Files for simple migrations such as adding/dropping columns are auto-generated by soda. For more complicated migrations, the migration files must be manually populated with explicit instructions.

Fizz provides a Go-like syntax for writing migrations, but [you may instead opt to write SQL migrations](https://github.com/gobuffalo/pop#generating-migrations). The fizz syntax is described [here](https://gobuffalo.io/en/docs/db/fizz/).

#### Migrating Pop Models

*Note: Pop models are distinct from go-swagger models! Go-swagger models represent API calls in golang, while pop models represent database entities in golang. See the [go-swagger docs](https://goswagger.io/use/models/schemas.html) to read about go-swagger models.*

Pop models are go files that describe database entities in terms of the go language. Each pop model corresponds to a table in the database. Soda can generate models from command-line input. When a migration modifies the database table that a model corresponds to, the associated model file must be manually edited.

For example, if you add a `province` column to the `individual` table in a migration, the `individual.go` model must have that field added to its `type Individual struct`. You may also want to add validations for this new field in the `Validate` method of the `individual.go` model.

#### Representing Associations with Pop

Associations between data resources should be specified in terms of a foreign key in the owning resource's `.fizz` (or `.sql`) migration file. Associations should also be specified in the pop models for all affected resources. One benefit of maintaining accurate associations in your pop models is that you can benefit from pop's [Eager association creation and (pre)loading](https://gobuffalo.io/en/docs/db/relations#loading-associations) functionality. Here are some useful guides for writing [1-to-1](https://blog.gobuffalo.io/associations-with-pop-1-to-1-592f02e2bdd8) and [1-to-n](https://blog.gobuffalo.io/associations-with-pop-1-to-n-2fb3e1c3833f) associations in Pop. More information about association tags used in pop models, such as `many_to_many`, can be found in the [docs](https://gobuffalo.io/en/docs/db/relations#available-struct-tags).

### Validating Pop Models

The `Validate` method contained in each model file, called upon each `ValidateAndSave` (or similar) call, checks that the data being pushed to the database meets desired constraints.

The `validators` package from Gobuffalo [validate](https://github.com/gobuffalo/validate) is a set of validators automatically imported by Pop. The `validate` package also allows for the creation of custom validators. See the `tools/validators` directory for a simple example, or the Unofficial pop Book's tutorial on [Writin Validations](https://andrew-sledge.gitbooks.io/the-unofficial-pop-book/content/advanced-topics/writing-validations.html) for a complex example.

#### Handling Nulls With Pop

There is some subtlety to representing database tables with Go structs. Since Go only allows `nil` values for pointers, a work-around is needed to handle nulls retrieved from the database, or to validate on nulls in data being pushed to the database.

By default, for a db datatype that is pop-converted into a non-nillable type in Go, null-values from the database are transformed into zero-values. For example, the `Chromosome` field of the `Variant` model (in `variant.go`) is of type string, and if a value for `chromosome` is not supplied in an entry, the value of the `Chromosome` field is `""`. The validators that check *required* fields provided in the `validators` package only check for these fields having a non-zero value. Thus, no distinction is made between zero-valued entries such as `0` or `""` and `nil`. **These validators are insufficient for cases where zero-valued entries are acceptable but `nil` entries are not.**

This project uses the `pop/nulls` package to handle non-nullable fields that should be permitted to have zero values, such as the `Start` field of the `Variant` model. This field is of type nulls.Int, which is able to differentiate between null values and zero values. A custom `int_is_not_null.go` validator is needed to validate this datatype.

### $POP_PATH

The database configuration file used by pop must be kept within one of the following paths, relative to the file attempting to connect with the database: 
  ```
  "", "./config", "/config", "../", "../config", "../..", "../../config", "APP_PATH", "POP_PATH"
  ```
Therefore the `POP_PATH` variable may be set to point to the folder containing the `database.yml` config file. See the [pop configuration code](https://github.com/gobuffalo/pop/blob/master/config.go) for more information.

## Genny

Genny is a code-generation solution to the lack of generics in Go. We use it handle the myriad of similarly-named auto-generated go files created by the pop and Go-Swagger tools.

See the [genny README](https://github.com/CanDIG/genny#genny---generics-for-go) for usage instructions and examples. It operates essentially like a copy-then-search-and-replace for generating typed functions out of functions written for generic types. This reduces code duplication by allowing for the development of type-agnostic code.

Run `$ model-vs/api/generate_handlers.sh` to re-generate the handlers in the `github.com/CanDIG/go-model-service/model-vs/api/restapi/handlers` package.

There remain several issues with the genny tool that block the complete integration of generic code-gen into our project. We appreciate contributions to the resolution of these issues in our [genny](https://github.com/CanDIG/genny/issues) repository.

## Postman

This [series of YouTube tutorials](https://www.youtube.com/watch?v=juldrxDrSH0&list=PLhW3qG5bs-L-oT0GenwPLcJAPD_SiFK3C) is a good introduction to most of the Postman functionality you'll want to know.

Postman can import an `swagger.yml` API definition to initialize a collection of tests for that API. The requests and tests comprising the collection must be manually configured, but once they are ready, they can be run automatically against a test datafile. The Newman CLI test runner can be used to run these tests from a continuous integration (CI) tool such as TravisCI or Jenkins. See [this guide](https://learning.postman.com/docs/postman/collection-runs/integration-with-travis/) for running a collection with TravisCI. 

## Docker

Docker containerizes processes so that they can be run in predictable environments, simplifying the process of dependency installation and minimizing interference with the host environment. See the [Docker tutorial](https://docker-curriculum.com/) and [Dockerfile reference](https://docs.docker.com/engine/reference/builder/#add) for more information.

Docker Compose automates the building and running of Docker containers. See the [tutorial](https://docs.docker.com/compose/gettingstarted/) and [reference](https://docs.docker.com/compose/compose-file/) documentation.

### Environment Variables for Docker Containers

It is common to run `docker` and `docker-compose` commands as `sudo`, because the socket used by the Docker daemon is owned by the `root` user. The downside to running  commands as `sudo` is that environment variables are not kept by default. This especially causes problems when building go services, which often depend upon the `$GOPATH` environment variable.

There are two solutions to this issue.
1) Always run sudo with the `-E` option (ie. `sudo -E <command>`) to explicitly preserve environment variables.
2) Create a user group to act as `root` when docker is run, as detailed [here](https://docs.docker.com/engine/install/linux-postinstall/#manage-docker-as-a-non-root-user). Be sure to read about the [security consequences](https://docs.docker.com/engine/security/security/#docker-daemon-attack-surface) before doing this!

Environment variables and/or `Dockerfile` arguments may also be misconfigured due to the confusing nature of `ENV`, `ARG`, `.env`, and env-file notation. For example, **the `.env` file is not the same thing as an "env-file"**. Further, while the `Dockerfile` or `docker-compose.yml` files used to build Docker containers may be otherwise named (with their filenames being specified with a `-f` option), the `.env` file **cannot be named anything else**. "Env-files", on the other hand, are not constrained by filename, and there may even be multiple "env-files" per build environment. For more information about Docker build-time and run-time environments, see [this guide](https://vsupalov.com/docker-arg-env-variable-guide/).

### Versioning Docker Images

Version control of Docker images is improved by proper version-tagging of images. This repository contains the `./push-image.sh` script that (optionally) builds, semantically versions, and pushes docker images to a repository such as Docker Hub. The versioning process follows the recommendations made in this [semantic versioning for Docker images](https://medium.com/@mccode/using-semantic-versioning-for-docker-image-tags-dfde8be06699) guide.
